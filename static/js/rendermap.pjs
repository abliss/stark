void setup() 
{
    stroke(0);
    strokeWeight(1);
    frameRate(15);
}
/*
void keyPressed() {
    if (!$(stark.player).attr('builder_mode')) {
        if (key == CODED) {
            if (keyCode == UP) { process_command('north'); }
            else if (keyCode == RIGHT) { process_command('east'); }
            else if (keyCode == DOWN) { process_command('south'); }
            else if (keyCode == LEFT) { process_command('west'); }
        }
    }
}
*/
/*
var size = 12;
var spacing = 10;
var margin = 5;

var draw_room = function(room, mapcenter, is_player_room) {
    // determine the true x starting position of the room in the canvas
    true_x = (room.xpos + Math.round(stark.map.width / 2) - stark.map.x) * (size + spacing);
    true_y = (room.ypos + Math.round(stark.map.height / 2) - stark.map.y)) * (size + spacing);

    // margin
    true_x = true_x + margin;
    true_y = true_y - margin;

    // connectors
    if (room.north == 'Normal') {
        line(true_x + Math.round(size / 2), true_y,
             true_x + Math.round(size / 2), true_y - Math.round(spacing / 2));
    }
    if (room.east == 'Normal') {
        line(true_x + size, true_y + Math.round(size / 2),
             true_x + size + Math.round(spacing / 2), true_y + Math.round(size / 2));
    }
    if (room.south == 'Normal') {
        line(true_x + Math.round(size / 2), true_y + size,
             true_x + Math.round(size / 2), true_y + size + Math.round(spacing / 2));
    }
    if (room.west == 'Normal') {
        line(true_x - Math.round(spacing / 2), true_y + Math.round(size / 2),
             true_x, true_y + Math.round(size / 2));
    }
    
    // room background color according to type
    if (room.type == 'road') {
        fill(#aa6e27);
    } else if (room.type == 'water') {
        fill(#3292dc);
    } else if (room.type == 'field') {
        fill(#27aa42);
    } else if (room.type == 'city') {
        fill(#D7CBB9);
    } else if (room.type == 'shop') {
        fill(#f5d494);
    }
    
    // highlight player room if applicable
    if (is_player_room) {
        stroke(#0000ff);
        strokeWeight(2);
    }
    
    rect(true_x, true_y, size, size);

    // reset to defaults before leaving
    stroke(0);
    strokeWeight(1);

}
 */

// the variable holding the stark x / y map center position that will
// actually get displayed, which may vary from the stark.map values for
// example in the case of a map shift where the animation needs to be smooth
//var map_center;

void draw() 
{
/*
    background(#EEEEEE);
    if ($(stark).attr('map')) {
        
        
        // smooth motion animation
        if (!map_center) { // initialization
            map_center = {
                x: stark.map.x,
                y: stark.map.y
            }
        } else {
            if (map_center.x > stark.map.x) { map_center.x--; }
            if (map_center.x < stark.map.x) { map_center.x++; }
            if (map_center.y > stark.map.y) { map_center.y--; }
            if (map_center.y < stark.map.y) { map_center.y++; }
        }
        
        
        var is_player_room;
        $.each(stark.map, function(key, object) {
            // don't render hidden rooms or anything that's not a room
            // (which for now means doesn't have a type)
            if (!object.type || object.type == 'hidden') { return true; }

            is_player_room = false;
            if ($(stark.room).attr('xpos') == object.xpos &&
                $(stark.room).attr('ypos') == object.ypos) {
                
                is_player_room = true;
            }
            
            draw_room(object, {}, is_player_room);

        });
    }
    */
}